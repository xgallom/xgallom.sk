export const Section04 = {
	title: 'XOS Development Blog - Hello World pt. 2',
	content: [
		{
			type: 'section',
			title: 'NAME',
			content: [{ type: 'paragraph', content: ['XOS Development Blog - Hello World'] }],
		},
		{
			type: 'section',
			title: 'BLOG PART FO\', GUNNA FUCK YO HOE',
			content: [
				{
					type: 'paragraph',
					content: [
						'Ayyyo wassup, we are finally looking into %BrightBlue%tty%Fg% and %BrightBlue%vga%Fg%. I did not ' +
						'write anything for a while, as I had other matters to attend to and was distracted by work and drugs. ' +
						'I hope my small fan base has not been decimated by this sudden discontinuation.',
					],
				},
			],
		},
		{
			type: 'section',
			title: 'VE GET ASS',
			content: [
				{
					type: 'paragraph',
					content: [
						'Unless we don\'t, in which case we suck. Whatever the case may be, we still get those fat ' +
						'stacks of pixels on that screen. VGA is extremely complicated interfaces, and going in depth ' +
						'is like 4 more episodes, and also me knowing more than the required basics. First of all, ' +
						'there is the video memory, mapped into either 0xa0000 or 0xb8000, different modes use different ' +
						'address spaces. The reasonable to expect default is the 80x25 16 colour text mode. In this ' +
						'mode, every character on the screen maps onto a 16 bit entry, with upper byte containing the ' +
						'colour and attributes, and lower byte containing the ASCII character to draw. Upper attribute ' +
						'nibble contains the background colour, and lower nibble contains the foreground colour. Both ' +
						'are encoded in the same scheme, bits 0-2 contain the colour space of 8 colours, and bit 3 sets ' +
						'the highlight attribute, which changes the colour intensity to bright, and may additionally ' +
						'make the text blink. Below is the character data layout as mapped in video memory:',
					],
				},
				{
					type: 'text_image',
					content: [
						'                      Text mode char                      ',
						'╔═══╦═════╦═══╦═════╦══════════╗                          ',
						'║ 1 ║ 010 ║ 0 ║ 111 ║ 01010010 ║                          ',
						'╚═══╩═════╩═══╩═════╩══════════╝                          ',
						' │ │ │   │ │ │ │   │ │        │                           ',
						' │ │ │   │ │ │ │   │ └────────┴─[8b] ASCII character      ',
						' │ │ │   │ │ │ │   │                                      ',
						' │ │ │   │ │ │ └───┴────────────[3b] Foreground colour    ',
						' │ │ │   │ │ │                                            ',
						' │ │ │   │ └─┴──────────────────[1b] Foreground brightness',
						' │ │ │   │                                                ',
						' │ │ └───┴──────────────────────[3b] Background colour    ',
						' │ │                                                      ',
						' └─┴────────────────────────────[1b] Background brightness',
					]
				},
				{
					type: 'paragraph',
					content: [
						'Each of the three colour bits control one colour from the RGB. Lowest bit controls the blue, ' +
						'middle bit controls green, and upper bit controls red. combining for example blue and green ' +
						'yields cyan. below is the colour table with standard colour mapping which is same as the ' +
						'colour mapping on this site:',
					],
				},
				{
					type: 'text_image',
					content: [
						'        ┌─┐                ┌─┐                ┌─┐                ┌─┐        ',
						'        │%Black%█%@%│                │%Blue%█%@%│                │%Green%█%@%│                │%Cyan%█%@%│        ',
						'        └─┘                └─┘                └─┘                └─┘        ',
						'       0 000              0 001              0 010              0 011       ',
						'       Black              Blue               Green              Cyan        ',
						'                                                                            ',
						'        ┌─┐                ┌─┐                ┌─┐                ┌─┐        ',
						'        │%Red%█%@%│                │%Magenta%█%@%│                │%Brown%█%@%│                │%Gray%█%@%│        ',
						'        └─┘                └─┘                └─┘                └─┘        ',
						'       0 100              0 101              0 110              0 111       ',
						'        Red              Magenta             Brown              Gray        ',
						'                                                                            ',
						'        ┌─┐                ┌─┐                ┌─┐                ┌─┐        ',
						'        │%DarkGray%█%@%│                │%BrightBlue%█%@%│                │%BrightGreen%█%@%│                │%BrightCyan%█%@%│        ',
						'        └─┘                └─┘                └─┘                └─┘        ',
						'       1 000              1 001              1 010              1 011       ',
						'     Dark Gray         Bright Blue       Bright Green        Bright Cyan    ',
						'                                                                            ',
						'        ┌─┐                ┌─┐                ┌─┐                ┌─┐        ',
						'        │%BrightRed%█%@%│                │%BrightMagenta%█%@%│                │%Yellow%█%@%│                │%White%█%@%│        ',
						'        └─┘                └─┘                └─┘                └─┘        ',
						'       1 100              1 101              1 110              1 111       ',
						'    Bright Red       Bright Magenta          Yellow             White       ',
						'                                                                            ',
					]
				},
				{
					type: 'paragraph',
					content: [
						'For example, writing 0x1e58 [0 001 1 110 1011000] would be a yellow \'X\' on blue background. ' +
						'This means, that we can encode a page of visual data as an array of 80x25 16 bit integers. ' +
						'Add a few bit operations for easier construction of the characters, and there you have it, ' +
						'a text mode vga layer for your everyday needs.',
						'',
						'Second is vga registers. There are many, but we currently only care about two: Cursor Location ' +
						'High Register and Cursor Location Low Register. Cursor position is represented as a 16 bit number, ' +
						'which is set to the offset of the cursor from the first character on the screen (row 0 column 0).' +
						'Simply setting this value to 80 would move the cursor to row 1 column 0, because one row is ' +
						'exactly 80 characters. setting it to 81 would move it to row 1 column 1. The way we set this number, ' +
						'is that we first write into the CRTC Address Register the address of the register we want to set, ' +
						'and then we write into the CRTC Data Register the value of the register we are setting. Address register is on ' +
						'0x3d4, and data register is on 0x3d5. Address of Cursor Location High Register is 0x0e, and ' +
						'Low Register is 0x0f. Both are 8 bits, and make together the 16 bit cursor position. Below is the header and the source files.',
					],
				},
				{
					type: 'text_image',
					content: [
						' '.repeat(120 - 8),
						'%BrightRed%xos/vga.h:%Fg%',
						'',
						'%Cpp%#include %Lit%<stddef.h>%@%',
						'%Cpp%#include %Lit%<stdint.h>%@%',
						'',
						'%Kw%namespace %Tp%vga %@%{',
						'    %Kw%namespace %Tp%Color %@%{',
						'        %Kw%enum %Tp%Enum %@%: %Tp%uint8_t %@%{',
						'                %Tp%Black %@%= %Lit%0%@%,',
						'               %Tp% Blue%@%,',
						'               %Tp% Green%@%,',
						'               %Tp% Cyan%@%,',
						'               %Tp% Red%@%,',
						'               %Tp% Magenta%@%,',
						'               %Tp% Brown%@%,',
						'               %Tp% Gray%@%,',
						'',
						'               %Tp% DarkGray%@%,',
						'               %Tp% BrightBlue%@%,',
						'               %Tp% BrightGreen%@%,',
						'               %Tp% BrightCyan%@%,',
						'               %Tp% BrightRed%@%,',
						'               %Tp% BrightMagenta%@%,',
						'               %Tp% Yellow%@%,',
						'               %Tp% White%@%',
						'        };',
						'',
						'        %Kw%static constexpr %Tp%uint8_t',
						'                %Gl%Offset %@%= %Lit%4u%@%,',
						'                %Gl%CombinationOffset %@%= %Gl%Offset %@%<< %Lit%1u%@%;',
						'    }',
						'',
						'    %Kw%static constexpr %Tp%uint16_t',
						'            %Gl%Width %@%= %Lit%80%@%,',
						'            %Gl%Height %@%= %Lit%25%@%,',
						'            %Gl%Total %@%= %Gl%Width %@%* %Gl%Height,',
						'            %Gl%TabLength %@%= %Lit%8%@%;',
						'',
						'    %Kw%inline constexpr',
						'    %Tp%uint8_t %Fn%ColorAttribute%@%(%Tp%Color%@%::%Tp%Enum %@%fg = %Tp%Color%@%::%Tp%\0Gray%@%,',
						'                           %Tp%Color%@%::%Tp%Enum %@%bg = %Tp%Color%@%::%Tp%\0Black%@%)',
						'    {',
						'            %Kw%return %@%fg | (bg << %Tp%Color%@%::%Gl%Offset%@%);',
						'    }',
						'',
						'    %Kw%void %Fn%renderFrameBuffer%@%(%Kw%const %Tp%uint16_t %@%*frameBuffer);',
						'    %Kw%void %Fn%setCursorPosition%@%(%Tp%uint16_t %@%position);',
						'}',
						'',
						'',
						'%BrightRed%vga.cpp:%Fg%',
						'',
						'%Cpp%#include %Lit%<xos/vga.h>%@%',
						'%Cpp%#include %Lit%<xos/port.h>%@%',
						'%Cpp%#include %Lit%<xos/string.h>%@%',
						'',
						'%Kw%namespace %Tp%vga %@%{',
						'    %Kw%static constexpr %Tp%uintptr_t %Gl%BufferAddress %@%= %Lit%0xb8000%@%;',
						'',
						'    %Kw%static inline %Tp%uint16_t %@%*%Fn%vgaBuffer%@%()',
						'    {',
						'            %Kw%return reinterpret_cast%@%<%Tp%uint16_t %@%*>(%Gl%BufferAddress%@%);',
						'    }',
						'',
						'    %Kw%void %Fn%renderFrameBuffer%@%(%Kw%const %Tp%uint16_t %@%*frameBuffer)',
						'    {',
						'            %Tp%xos%@%::%Fn%memcpy%@%(%Fn%vgaBuffer%@%(), frameBuffer, %Gl%Total%@%);',
						'    }',
						'',
						'    %Kw%void %Fn%setCursorPosition%@%(%Tp%uint16_t %@%position)',
						'    {',
						'            %Kw%const %Tp%uint8_t%@%',
						'                    low = position & %Lit%0xffu%@%,',
						'                    high = (position >> 8u) & %Lit%0xffu%@%;',
						'',
						'            %Fn%outb%@%(%Lit%0x3d4u%@%, %Lit%0x0eu%@%);',
						'            %Fn%outb%@%(%Lit%0x3d5u%@%, high);',
						'',
						'            %Fn%outb%@%(%Lit%0x3d4u%@%, %Lit%0x0fu%@%);',
						'            %Fn%outb%@%(%Lit%0x3d5u%@%, low);',
						'    }',
						'}',
						'\n',
					],
				},
			],
		},
		{
			type: 'section',
			title: 'ITTY TTY COMMITTEE',
			content: [
				{
					type: 'paragraph',
					content: [
						'refers to a teleprinter or a teletypewriter, a device from early 20th century used to send typed ' +
						'messages. Later replaced by a computer terminal, which was referred to as tty in Unix systems for ' +
						'historic reasons.',
						'',
						'Header is pretty simple, contains only some self explanatory declarations.',
					],
				},
				{
					type: 'text_image',
					content: [
						' '.repeat(120 - 8),
						'%BrightRed%xos/tty.h:%@%',
						'',
						'%Cpp%#include %Lit%<stddef.h>%@%',
						'%Cpp%#include %Lit%<stdint.h>%@%',
						'',
						'%Kw%namespace %Tp%tty %@%{',
						'    %Kw%void %Fn%initialize%@%();',
						'',
						'    %Kw%void %Fn%clear%@%();',
						'    %Kw%void %Fn%putchar%@%(%Kw%char %@%c);',
						'',
						'    %Kw%void %Fn%write%@%(%Kw%const char %@%*data, %Tp%size_t %@%size);',
						'    %Kw%void %Fn%write%@%(%Kw%const char %@%*data);',
						'',
						'    %Kw%void %Fn%setColor%@%(%Tp%uint8_t %@%color);',
						'    %Kw%void %Fn%setCursor%@%(%Tp%uint16_t %@%position);',
						'    %Kw%void %Fn%setCursor%@%(%Tp%uint8_t %@%x, %Tp%uint8_t %@%y);',
						'}',
					],
				},
				{
					type: 'paragraph',
					content: [
						'I will not go in-depth with these sources, they are documented. We keep a framebuffer that ' +
						'we fill with putchars. It has one more line which is invisible, and when we hit last line ' +
						'we memmove whole framebuffer from second row into the first row, effectively moving all the ' +
						'text one row up, and filling the last line with the invisible row. When we finish an operation, ' +
						'we update the new cursor position and render the frame buffer, so putcharing 10 times causes ' +
						'10 cursor updates and 10 redraws, but writing 10 characters does only one update and redraw.',
					],
				},
				{
					type: 'text_image',
					content: [
						' '.repeat(120 - 8),
						'%BrightRed%tty.cpp:%@%',
						'',
						'%Kw%#include %Lit%<xos/tty.h>',
						'%Kw%#include %Lit%<xos/vga.h>',
						'%Kw%#include %Lit%<xos/string.h>',
						'%Kw%#include %Lit%<stdint.h>',
						'',
						'%Kw%namespace %Tp%tty %@%{',
						'    %Cm%// Frame buffer is uint16_t, because vga maps attribute plane interwoven%@%',
						'    %Cm%//  with character plane.%@%',
						'    %Cm%// Even byte is attribute, and odd byte is character of specific screen%@%',
						'    %Cm%//  position, so screen characters can map to words that have attribute in%@%',
						'    %Cm%//  high byte and character in low byte.%@%',
						'',
						'    %Cm%// Frame buffer has one more empty row.%@%',
						'    %Cm%// On having full buffer, whole screen is copied one row up, along with the%@%',
						'    %Cm%//  spare row, which fills the last row with empty characters%@%',
						'    %Kw%static %Tp%uint16_t %Gl%s_frameBuffer%@%[%Tp%vga%@%::%Gl%Total %@%+ %Tp%vga%@%::%Gl%Width%@%] = {};',
						'',
						'    %Kw%static %Tp%uint16_t %Gl%s_position %@%= %Lit%0%@%;',
						'',
						'    %Cm%// Attributes are stored in the higher byte so they don\'t have to be shifted%@%',
						'    %Cm%//  on every write, only on every setColor.%@%',
						'    %Kw%static %Tp%uint16_t %Gl%s_attributeMask %@%= %Lit%0%@%;',
						'',
						'    %Kw%static void %Fn%internal_putchar%@%(%Kw%char %@%c)',
						'    {',
						'            %Kw%switch %@%(c) {',
						'            %Kw%case %Lit%\'%@%\\n%Lit%\'%@%:',
						'                    %Cm%// Add remaining offset to end of current row to position%@%',
						'                    %Gl%s_position %@%+= %Tp%vga%@%::%Gl%Width %@%- %Gl%s_position %@%% %Tp%vga%@%::%Gl%Width%@%;',
						'                    %Kw%break%@%;',
						'',
						'            %Kw%case %Lit%\'%@%\\t%Lit%\'%@%:',
						'                    %Gl%s_position %@%+= %Tp%vga%@%::%Gl%TabLength %@%- %Gl%s_position %@%% %Tp%vga%@%::%Gl%TabLength%@%;',
						'                    %Kw%break%@%;',
						'',
						'            %Kw%default%@%:',
						'                    %Gl%s_frameBuffer%@%[%Gl%s_position%@%++] = %Gl%s_attributeMask %@%| %Tp%uint8_t%@%(c);',
						'                    %Kw%break%@%;',
						'            }',
						'',
						'            %Kw%if %@%(%Gl%s_position %@%>= %Tp%vga%@%::%Gl%Total%@%) {',
						'                    %Cm%// On overflow next row of the frame buffer is moved one row%@%',
						'                    %Cm%//  up, along with the spare empty row.%@%',
						'                    %Gl%s_position %@%-= %Tp%vga%@%::%Gl%Width%@%;',
						'',
						'                    %Tp%xos%@%::%Fn%memmove%@%(',
						'                            %Gl%s_frameBuffer%@%,',
						'                            %Gl%s_frameBuffer %@%+ %Tp%vga%@%::%Gl%Width%@%,',
						'                            %Tp%vga%@%::%Gl%Total%@%',
						'                    );',
						'            }',
						'    }',
						'',
						'    %Kw%void %Fn%initialize%@%()',
						'    {',
						'            %Fn%setColor%@%(%Tp%vga%@%::%Fn%ColorAttribute%@%());',
						'            %Fn%clear%@%();',
						'    }',
						'',
						'    %Kw%void %Fn%clear%@%()',
						'    {',
						'            %Tp%xos%@%::%Fn%memset%@%(%Gl%s_frameBuffer%@%, %Gl%s_attributeMask%@%);',
						'',
						'            %Tp%vga%@%::%Fn%setCursorPosition%@%((%Gl%s_position %@%= %Lit%0%@%));',
						'            %Tp%vga%@%::%Fn%renderFrameBuffer%@%(%Gl%s_frameBuffer%@%);',
						'    }',
						'',
						'    %Kw%void %Fn%putchar%@%(%Kw%char %@%c)',
						'    {',
						'            %Fn%internal_putchar%@%(c);',
						'',
						'            %Tp%vga%@%::%Fn%setCursorPosition%@%(%Gl%s_position%@%);',
						'            %Tp%vga%@%::%Fn%renderFrameBuffer%@%(%Gl%s_frameBuffer%@%);',
						'    }',
						'',
						'    %Kw%void %Fn%write%@%(%Kw%const char %@%*data, %Tp%size_t %@%size)',
						'    {',
						'            %Kw%if %@%(!size)',
						'                    %Kw%return%@%;',
						'',
						'            %Kw%do%@%',
						'                    %Fn%internal_putchar%@%(*data++);',
						'            %Kw%while %@%(--size);',
						'',
						'            %Tp%vga%@%::%Fn%setCursorPosition%@%(%Gl%s_position%@%);',
						'            %Tp%vga%@%::%Fn%renderFrameBuffer%@%(%Gl%s_frameBuffer%@%);',
						'    }',
						'',
						'    %Kw%void %Fn%write%@%(%Kw%const char %@%*data)',
						'    {',
						'            %Kw%char %@%character = *data;',
						'',
						'            %Kw%if %@%(!character)',
						'                    %Kw%return%@%;',
						'',
						'            %Kw%do%@%',
						'                    %Fn%internal_putchar%@%(character);',
						'            %Kw%while %@%((character = *++data));',
						'',
						'            %Tp%vga%@%::%Fn%setCursorPosition%@%(%Gl%s_position%@%);',
						'            %Tp%vga%@%::%Fn%renderFrameBuffer%@%(%Gl%s_frameBuffer%@%);',
						'    }',
						'',
						'    %Kw%void %Fn%setColor%@%(%Tp%uint8_t %@%color)',
						'    {',
						'            %Gl%s_attributeMask %@%= %Tp%uint16_t%@%(color) << %Lit%8u%@%;',
						'    }',
						'',
						'    %Kw%void %Fn%setCursor%@%(%Tp%uint16_t %@%position)',
						'    {',
						'            %Tp%vga%@%::%Fn%setCursorPosition%@%((%Gl%s_position %@%= position));',
						'    }',
						'',
						'    %Kw%void %Fn%setCursor%@%(%Tp%uint8_t %@%x, %Tp%uint8_t %@%y)',
						'    {',
						'            %Tp%vga%@%::%Fn%setCursorPosition%@%((%Gl%s_position %@%= y * %Tp%vga%@%::%Gl%Width %@%+ x));',
						'    }',
						'}',
					],
				},
			],
		},
		{
			type: 'section',
			title: 'PRETTY ANTICLIMACTIC HUH',
			content: [
				{
					type: 'paragraph',
					content: [
						'I know right?!',
						'',
						'But also not, because the TTY code is pretty long, especially when compared with ' +
						'anything else we currently looked at. I hope you enjoyed this episode, and I look forward to ' +
						'bringing you more news from the world of xos, in the following episodes you can look forward to ' +
						'seeing more multiboot, gdt and cpuid.',
						'',
						'Signed-off-by: Milan Gallo <gallo.milan.jr@gmail.com>'
					],
				},
			],
		},
	],
};

